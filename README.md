<h2>Описание проекта "Авиакомпания UX Air"</h2>

- [Summary](#summary)
- [Stack](#stack)
- [MVP](#mvp)
- [Backlog](#backlog)
- [Структура проекта](#структура-проекта)
    - [Бэкенд](#бэкенд)
    - [Фронтенд](#фронтенд)
- [Работа на проекте](#работа-на-проекте)
    - [С чего начинать](#с-чего-начинать)
    - [О таскборде](#о-таскборде)
    - [Как выполнять задачи](#как-выполнять-задачи)
    - [Проверка задач](#проверка-задач)
    - [Требования к коду](#требования-к-коду)
    - [Созвоны по проекту](#созвоны-по-проекту)
- [Дополнительные материалы](#дополнительные-материалы)
    - [Spring Boot Dev Tools](#Spring Boot Dev Tools)
    - [Аутентификация](#аутентификация)
    - [Liquibase](#liquibase)


### Summary

Реализуем функционал авиакомпании на основе прототипа дизайна - [UX Air](https://www.figma.com/file/kbfQhRHVicK6uALg5tBfed/UXDI---Project-15--Annotations---Airline-Website-UXAIR-(Community)).
При выполнении тасок ориентируемся на дизайн по ссылке выше.

Проект рассчитан на студентов, успешно завершивших этап Pre-Project в Kata Academy.

### Stack

Проект пишется на базе `Java 17`, `Spring Boot 3`, `Maven` и архитектуре REST. Работаем с базой данных `PostgreSQL` через `Spring Data` и `Hibernate 6`.

Чтобы не писать boilerplate-код, используем на проекте [Lombok](https://projectlombok.org/features/all).

Все контроллеры и их методы нужно сразу описывать аннотациями [Swagger](https://docs.swagger.io/swagger-core/v1.5.0/apidocs/allclasses-noframe.html) в интерфейсах к контроллерам

Таск-борд находится прямо на [Bitbucket](https://jora.kata.academy/secure/RapidBoard.jspa?rapidView=2&projectKey=AV45937455).

Dev-stand будем поднимать и разворачивать через Docker, а настраивать CI/CD - через Gitlab.


### RULES

 1. Проект пишется согласно SOLID правилам
 2. Базовая архитектура приложения состоит из трех частей: connector / back / client
       - connector layer включает себя feing клиенты для связи с другими микросервисами 
       - back layer содержит в себе сервисы логики и read/write сервисы в связке repository, так же в этот слой включены модели и util классы
       - client layer содержит себе контроллеры и фасады, которые используются в контроллерах. Фасад соеденяет не связанные друг с другом сервисы воедино и предоставляет более простой интерфейс для контроллеров

### MVP

[MVP](https://ru.wikipedia.org/wiki/%D0%9C%D0%B8%D0%BD%D0%B8%D0%BC%D0%B0%D0%BB%D1%8C%D0%BD%D0%BE_%D0%B6%D0%B8%D0%B7%D0%BD%D0%B5%D1%81%D0%BF%D0%BE%D1%81%D0%BE%D0%B1%D0%BD%D1%8B%D0%B9_%D0%BF%D1%80%D0%BE%D0%B4%D1%83%D0%BA%D1%82) - API (полностью описанное в Swagger), которое будет уметь продавать, менять, возвращать авиабилеты.
Работать с таким API можно будет через веб-интерфейс Swagger и Postman.

### Backlog

Фичи:
<ul>
<li>диверсификация перевозок (багаж, животные, oversized-вещи, грузы)</li>
<li>создание личного кабинета пассажира, добавление аутентификации через логин/пароль, Google, социальные сети</li>
<li>реализация функционала обратной связи с пассажиром через e-mail и Telegram</li>
<li>создание личного кабинета администратора</li>
<li>внедрение бонусной системы (мили), кэшбека и акций</li>
<li>внедрение проверок пассажиров по стоп-листам - общение с микросервисом "МВД"</li>
<li>добавление смежных сервисов - подбора гостиниц, аренды квартир, трансферов, каршеринга, экскурсий. Все - микросервисы.</li>
</ul>

Импрувменты:

<ul>
<li>логирование через Slf4j + log4j2</li>
<li>юнит-тесты и интеграционные тесты</li>
<li>анализ качества кода через SonarQube</li>
</ul>


## Структура проекта
### ERD
### Бэкенд

Проект основан на архетипе webapp.
Слои:
<ul>
<li><code>config</code> конфигурационные классы, в т.ч. Spring Security, инструменты аутентификации</li>
<li><code>entity</code> сущности базы данных</li>
<li><code>dto</code> специальные сущности для передачи/получения данных в/с апи</li>
<li><code>repository</code> dao-слой приложения, реализуем в виде интерфейсов Spring Data, имплементирующих JpaRepository.</li>
<li><code>service</code> бизнес-логика приложения, реализуем в виде интерфейсов и имплементирующих их классов.</li>
<li><code>controller</code> обычные и rest-контроллеры приложения.</li>
<li><code>util</code> пакет для утилитных классов: валидаторов, шаблонов, хэндлеров, эксепшнов.</li>
</ul>

### Фронтенд
Фронтенд пишет команда фронтенда. Наша задача - дать возможность фронту обращаться к API нашего приложения

## Работа на проекте
### С чего начинать

Доступы. Если ты читаешь это, значит доступ к проекту у тебя уже есть )
<ol>
<li>загрузи проект себе в среду разработки</li>
<li>изучи весь проект - начни с pom, properties файлов и конфигурационных классов</li>
<li>создай локальную базу данных PostgeSQL с названием <code>airline_db</code>. Можешь изменить параметры доступа (логин, пароль) в конфиге проекта под свои нужды, 
но не отправляй эти данные в Git</li>
<li>добейся успешного запуска проекта. <a href="http://localhost:8888/"> Проверить</a>.</li>
<li>изучи <a href="https://gitlab.com/devs_hub/p_mf_airline_2/-/boards/4500816">таск-борд</a>
</ol>

Для отправки почты используется Google аккаунт.<br/>
Вход в него с именем "uxair1.kata" и паролем "Mail4@Uxair1" (без кавыек).<br/>
Важно учитывать, что для отправки почты использзуется отдельный пароль (т.н пароль приложения),
так как в случае наличи двухфакторной аутентификации использование пароля от эккаунта не позволит отправить почту.<br/>
Именно данный пароль и указан в найстройке в .yml файле.
При отправке почты всегда можно зайти в эккаунт через браузер и проверить, что она в папке Отправленные.

### О таскборде

Таск-борд строится по принципу Kanban - он разделён на столбцы, каждый из которых соответствует определённому этапу работы с задачей:
<ul>
<li><code>Backlog</code> задачи на <b>новый функционал</b>, корзина функционала приложения. Здесь можете создавать карточки на таски, которые считаете необходимыми</li>
<li><code>TODO</code> задачи, требующие выполнения</li>
<li><code>In Progress</code> выполняемые в данный момент задачи, обязательно должны иметь исполнителя</li>
<li><code>Cross-review </code> задачи на этапе перекрёстной проверки студентами</li>
<li><code>Final Review</code> задачи на проверке у техлида</li>
<li><code>Closed</code> выполненные задачи</li>
</ul>

У каждой задачи есть теги:
<ul>
<li><code>Feature/Refactor</code> - новый функционал или переработка существующего</li>
<li><code>Bug</code> - таска на исправление бага до или после тестирования</li>
<li><code>Reworking</code> - таска на исправлении замечаний после кросс или файнал ревью</li>
<li><code>InQA</code> - задача с такой меткой находится у тестировщика в работе </li>
<li><code>Backlog, ToDo, InProgress, CrossReview, FinalReview</code> - этапы прохождения задачи по борде</li>
</ul>


### Как выполнять задачи

<ul>
<li>в графе <code>TODO</code> на таск-борде выбери карточку с задачей и назначь её себе для исполнения</li>
<li>загрузи себе последнюю версию ветки <code>develop</code></li>
<li>создай от <code>develop</code> свою собственную ветку для выполнения взятой задачи. Свою ветку назови так, чтобы было понятно, чему посвящена задача. В начале имени ветки проставь номер задачи с Gitlab. Например, <code>313_adding_new_html_pages</code></li>
<li>выполни задачу, обязательно сделай юнит-тесты на методы и, если всё ок, залей её в репозиторий проекта</li>
<li>создай на своей ветке merge request, в теле реквеста укажи <code><i>Closes #здесь-номер-таски"</i></code>. Например, <code>Closes #313</code></li>
<li>перенеси задачу в столбец <code>Cross-review</code></li>
</ul>

### Проверка задач

На этапе кросс-ревью студенты проверяют задачи, выполненные друг другом.
В случае, если к коду есть замечания, проверяющий пишет замечания в мердж реквесте и оставляет комментарий в карточке.
Если к коду претензий нет, проверяющий студент ставит к карточке лайк.

**Каждая карточка (студенческая задача) должна быть проверена как минимум 2 другими студентами и одобрена ими (т.е. собрать не менее 2 лайков).**

Только после этого карточку можно переносить в столбец `Final Review`.

Затем код проверяет техлид (ментор) и в случае обнаружения ошибок ставит тег `Reworking` и переносит её в столбец `InProgress`.
Если всё ок - merge request принимается, ветка студента сливается с основной веткой проекта, а карточка переносится в столбец `Closed`.

### Требования к коду

- сделайте себе понятные никнеймы (имя + фамилия) в Git. Не хочу гадать, кто, где и что писал.
- для каждого класса и (желательно) методов пишите комментарии в формате <b>Javadoc</b>:
    - над классом: что это за класс, зачем нужен. Описывайте поля.
    - над методом: что делает, какие параметры принимает (и что это такое), что возвращает.
- свободно создавайте собственные вспомогательные классы в пакете Util - типа утилиток для страховки от null и типа того.
- в REST-контроллерах пользоваться аннотациями Swagger - причём как сами контроллеры в целом, так и их отдельные методы. Посмотрите пример в проекте
- на полях сущностей можно и нужно расставлять констрейнты для проверки формата, длины введённых значений, проверки чисел на положительность и т.д.
- пишите Commit message как можно более подробно! На английском языке - пользуйтесь переводчиком при необходимости.

Если в процессе разработки вы пришли к пониманию того, что требуется создать какую-то ещё сущность - создавайте карточку в `Open`, согласуйте ее с тимлидом и вперёд

### Требования к логированию работы контроллеров:

1. В каждый метод необходимо добавить логирование с описанием произведенной операции на уровне info.

2. Если объект не найден, вывести сообщение уровня warning ("not found" или "does not exist") с описанием произведенной операции.

### Созвоны по проекту

Созвоны проходят по вторникам и четвергам в оговорённое время.
Регламент:
- длительность до 15 минут
- формат: доклады по 3 пунктам:
    - что сделано с прошлого созвона
    - какие были/есть трудности
    - что будешь делать до следующего созвона
- техлид (ментор) на созвонах код не ревьюит

Любые другие рабочие созвоны команда проводит без ограничений, т.е. в любое время без участия техлида.
Договаривайтесь сами :)

## Дополнительные материалы
### Spring Boot Dev Tools

Благодаря данной зависимости, разработчик получает возможность ускорить разработку проекта на Spring Boot в IDEA IDE и сделать этот процесс более приятным и продуктивным. А не вручную перегружать сборку каждый раз, когда надо проверить код. IDEA будет делать это за него.

####Как подключить
+ [mkyong.com](https://mkyong.com/spring-boot/intellij-idea-spring-boot-template-reload-is-not-working/)
+ [metakoder.com](https://www.metakoder.com/blog/spring-boot-devtools-on-intellij/)
+ [YouTube Video](https://youtu.be/XYTET4vSn6k)

####Полезные ссылки:
+ [baeldung.com](https://www.baeldung.com/spring-boot-devtools)
+ [habr.com](https://habr.com/ru/post/479382/)

### Аутентификация

В проект подключена аутентификация с помощью keycloak, который поднимается в docker запускам файла
keycloak-docker-compose.yml, в котором совместно с keycloak также поднимается база данных, и настраиваются пользователи.
Для доступа к keycloak используется пользоватье с логином keycloak-admin и паролем admin.
Так же создаётся реалм airline-realm, который используется для авторизации в приложении.
Тестовые пользователи в нём admin и user с паролями admin и user соответственна, у админа назначена роль admin, у
user - passenger.

В контроллер AuthenticateController в метод authenticate передаётся DTO с именем и паролем в случае успешной
аутентификации он возвращает токен который потом используется в запросах для
доступа к эндпоинтам котрноллеров. Для того чтобы организавать аторизованный доступ к эндпоинтам контроллеров достаточно
пометить метод контроллера аннотацией **_@PreAuthorize()_** и в скобках указать роль например _**hasRole('admin')**_
В keycloak настроены роли supeAdmin, admin, manager, passenger.

#### Пример метода:
````java
 @GetMapping("/admin")
 @PreAuthorize("hasRole('admin')")
 public String getAdminInfo() {
   return "admin info";
 } 
````

### Liquibase

#### Инструкция для разработчика по созданию скриптов миграции

1. В файле проекта **pom.xml** установить уникальное значение в настройке liquibase.tag.<br> Например: <liquibase.tag>79_all_tables_liquibase</liquibase.tag>
2. Внести планируемые изменения и откомпилировать свой код.<br> 📌 Замечание: важно помнить, что генерация скрипта миграции идет не по исходникам, а по скомпилированным классам.
3. Перед выполнением изменений в структуре БД навесить tag на ее текущую структуру (для возможного отката):
- Либо с использованием плагина liquibase выполнить цель tag (liquibase:tag)
- Либо в командной строке исполнить “mvn liquibase:tag” (без кавычек)
4. Сформировать скрипт миграции с текущей версии структуры БД до необходимой для поддержки изменений в коде:
- Либо в плагине liquibase запустить цель diff (liquibase:diff)
- Либо в командной строке исполнить “mvn liquibase:diff”
  <aside>
  📌 При выполнении задачи появятся предупреждения:<br>
  [WARNING] HHH000342: Could not obtain connection to query metadata java.lang.UnsupportedOperationException: The application must supply JDBC connections…<br> 
  и<br>
  [WARNING] Failed to create parent directories for file….<br>
  Пока их игнорируем.
  </aside>

В результате в каталоге **src/resources/db/changelogs** должен появится файл (скрипт миграции в yaml формате) с названием типа  `20221028-162423_changelog.yaml` (цифры у вас будут другими). Он содержит “разницу” между текущей структурой БД и теми изменениями, что вы планируете внести через entities.
5. Добавить в конец файла **src/resources/db.changelog-master.yaml** ссылку на только что созданный скрипт миграции, например:<br>
   databaseChangeLog:<br>
   <space/><space/>\- include:<br>
   <space/><space/><space/><space/>file: db/changelog/db.changelog-20221028-162423_changelog.yaml<br>
   Замечание: Важно соблюсти формат по отступам слева, придерживайтесь формата ранее внесенных записей в качестве образцов.
6. Учитывая замечания пункта 2, перенести измененный db.changelog-master.yaml и скрипт миграции в каталог target/classes/db/changelog (для простоты можно снова все откомпилировать, тогда среда разработки сделает перенос за вас)
7. Опциональный шаг. Ознакомтесь предварительно со скриптом миграции:
- Либо в плагине liquibase запустить цель updateSQL (liquibsed:updateSQL)
- Либо исполнить в командной строке “mvn liquibase:updateSQL”

В результате в каталоге **target\liquibase** (не путать с каталогом target\classes\liquibase) появится файл **migrate.sql**. Изучите его.
8. Обновить БД скриптом миграции:
- Либо в плагине liquibase запустить цель update (liquibsed:update).
- Либо исполнить в командной строке “mvn liquibase:update”
9. Прогнать тесты. По результатам:
- Если все ОК - влить в Git скрипт миграции и все ваши изменения.
- Если выявлены проблемы по причине некорректной структуры данных - требуется откат миграции БД к версии, отмеченной тагом на шаге 3.<br>

  Для выполнения отката:

    - либо в плагине liquibase вызвать цель rollback (liquibase:rollback)
    - либо исполнить в командной строке “mvn liquibase:rollback”

  Далее перейти на шаг 2. При этом, до выполнения коммита, шаг 3 (навешивание тэга) можно пропускать.


####Допольнительная информация по Liquibase

[Liquibase](https://www.liquibase.org/) — это опенсорс проект, который помогает разработчикам быстро управлять изменениями базы данных.

Основные фичи:
- возможность гибкого изменения баз данных (поддерживает SQL, XML, YAML и JSON)
- автоматическая генерация SQL скриптов
- возможность повторять миграции
- поддержка расширений и интеграций
- система отката изменений (rollbacks)

![](/Users/nanomachine/Desktop/Снимок экрана 2022-10-07 в 17.25.28.png)

Все изменения базы данных указаны в файле журнала (changelog) изменений Liquibase.
Изменения содержится в наборе изменений, а наборы изменений (changeset) добавляются в журнал изменений в том порядке,
в котором они должны быть развернуты.

![](/Users/nanomachine/Downloads/liquibase-xml-changelog.jpeg)

Проще говоря — журнал изменений содержит упорядоченный список наборов изменений (changesets), а набор изменений содержит само изменение (changeset).

Вы можете указать изменения базы данных в одном из четырех форматов:
SQL, XML, JSON или YAML.
Также можете их комбинировать.

После создания журнала изменений (changelog), запуск Liquibase Update развертывает все неразвернутые изменения в указанной базе данных. Обратите внимание, что Liquibase отслеживает, что развернуто, а что нет в таблице DATABASECHANGELOG.

[Ссылка 1](https://habr.com/ru/post/460377/)

[Ссылка 2](https://habr.com/ru/post/460907/)#   P R O J E C T M T H F C K  
 